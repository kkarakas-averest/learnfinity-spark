"""
Content Creation Agent for the learning platform.
This agent creates course content based on learning paths.
"""

import os
import sys
import json
from datetime import datetime
import uuid
import requests

# Add parent directory to path to import correctly
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from agents.db_utils import (
    load_learning_path,
    load_employee_profile,
    save_course_content
)

# Import dotenv for environment variables
from dotenv import load_dotenv
load_dotenv()

# Import our custom Groq API integration
try:
    from lib.llm.llm_service import LLMService
    from lib.llm.groq_api import GroqAPI
    groq_api_available = True
except ImportError:
    print("WARNING: Custom Groq API integration not available")
    groq_api_available = False

# Get API key
GROQ_API_KEY = os.getenv('VITE_GROQ_API_KEY')
if not GROQ_API_KEY:
    GROQ_API_KEY = os.getenv('GROQ_API_KEY')
    if not GROQ_API_KEY:
        print("WARNING: No Groq API key found in environment variables")

class ContentCreationAgent:
    """
    Agent responsible for creating course content based on learning paths
    generated by the Personalization Agent.
    """
    
    def __init__(self):
        """Initialize the Content Creation Agent"""
        # Initialize our Groq API
        self.llm_service = None
        self.groq_api = None
        
        # Available models (in preference order)
        self.available_models = [
            'llama3-8b-8192',
            'llama3-70b-8192',
            'gemma-7b-it'
        ]
        self.default_model = 'llama3-8b-8192'
        
        if GROQ_API_KEY and groq_api_available:
            try:
                # Initialize our custom Groq LLM service
                self.llm_service = LLMService.getInstance({
                    'provider': 'groq',
                    'apiKey': GROQ_API_KEY, 
                    'model': self.default_model,
                    'debugMode': True
                })
                # For direct API access
                self.groq_api = GroqAPI(
                    GROQ_API_KEY,
                    self.default_model,
                    {'debug': True}
                )
                print("Content Creation Agent initialized with custom Groq API integration")
                
                # Verify model availability
                self._check_model_availability()
            except Exception as e:
                print(f"Error initializing custom Groq API: {str(e)}")
                self.llm_service = None
                self.groq_api = None
        else:
            print("Warning: Falling back to mock content generation")
    
    def _check_model_availability(self):
        """Check if the configured model is available and update if needed"""
        if not self.groq_api:
            return
            
        try:
            # Request available models from Groq API
            headers = {
                "Authorization": f"Bearer {GROQ_API_KEY}"
            }
            
            response = requests.get("https://api.groq.com/openai/v1/models", headers=headers)
            
            if response.status_code != 200:
                print(f"Warning: Failed to check model availability. Status code: {response.status_code}")
                return
                
            models_data = response.json()
            available_models = [model["id"] for model in models_data.get("data", [])]
            
            # Check if current model is available
            current_model = self.groq_api.getModel()
            
            if current_model not in available_models:
                print(f"Warning: Current model '{current_model}' is not available in Groq API")
                
                # Try to find an available model from our preference list
                for model in self.available_models:
                    if model in available_models:
                        print(f"Switching to available model: {model}")
                        self.groq_api.setModel(model)
                        if self.llm_service:
                            self.llm_service.setModel(model)
                        return
                        
                print("Warning: No preferred models are available. Falling back to mock content generation")
                self.groq_api = None
                self.llm_service = None
            else:
                print(f"Model '{current_model}' is available and will be used for content generation")
                
        except Exception as e:
            print(f"Error checking model availability: {str(e)}")
    
    def create_course_content(self, employee_id, course_id, course_info):
        """
        Create content for a course based on the course information
        
        Args:
            employee_id: The ID of the employee
            course_id: The ID of the course to create content for
            course_info: Information about the course
            
        Returns:
            The course content
        """
        # Load employee profile to personalize content
        profile = load_employee_profile(employee_id)
        if not profile:
            raise ValueError(f"No profile found for employee {employee_id}")
        
        # Generate course content using Groq API if available
        if self.groq_api and self.groq_api.isConfigured():
            print(f"Using Groq API to generate content for course: {course_info.get('title', 'Untitled')}")
            return self._generate_course_content_with_groq(course_id, course_info, profile)
        else:
            # Fallback to mock content generation
            print(f"Using mock generator for course: {course_info.get('title', 'Untitled')}")
            return self._generate_mock_course_content(course_id, course_info, profile)
    
    def _generate_course_content_with_groq(self, course_id, course_info, profile):
        """Generate course content using Groq API"""
        try:
            # Build the prompt for the course overview
            overview_prompt = f"""
            Create a comprehensive course overview for a course titled "{course_info.get('title', 'Untitled Course')}".
            
            The course is for an employee with the following profile:
            {json.dumps(profile, indent=2)}
            
            Course information:
            {json.dumps(course_info, indent=2)}
            
            Please generate a detailed course overview in JSON format with the following structure:
            {{
                "summary": "A concise but informative summary of the course",
                "key_concepts": ["List of 3-5 key concepts covered"],
                "prerequisites": ["Any prerequisite knowledge or skills"],
                "target_audience": ["The intended audience"],
                "difficulty_level": "Beginner/Intermediate/Advanced",
                "estimated_completion_time": "Estimated time to complete the course"
            }}
            """
            
            # Get the course overview
            overview_response = self.groq_api.complete(overview_prompt, {
                'temperature': 0.3,
                'maxTokens': 1000,
                'system': 'You are an expert course content creator who produces high-quality educational materials.'
            })
            
            # Parse the overview
            try:
                course_overview = json.loads(overview_response.text)
            except json.JSONDecodeError:
                # Fallback if the response isn't valid JSON
                course_overview = self._generate_course_overview(course_info, profile)
                
            # Build prompt for module generation
            modules_prompt = f"""
            Create {min(5, int(course_info.get('estimated_duration', '10 hours').split()[0]) // 2)} educational modules for a course titled "{course_info.get('title', 'Untitled Course')}".
            
            Course overview:
            {json.dumps(course_overview, indent=2)}
            
            Employee profile:
            {json.dumps(profile, indent=2)}
            
            For each module, include:
            1. A title and sequence number
            2. Introduction text explaining the module
            3. 3-4 sections, each with a title and content
            4. A summary of the module
            5. A quiz with 5 questions to test understanding
            
            Return the modules as a JSON array following this structure:
            [
                {{
                    "id": "unique_id",
                    "title": "Module Title",
                    "sequence_order": 1,
                    "content": {{
                        "introduction": "Introduction text",
                        "sections": [
                            {{
                                "title": "Section Title",
                                "content": [
                                    {{"type": "text", "value": "Text content"}},
                                    {{"type": "code_example", "value": "Sample code"}}
                                ]
                            }}
                        ],
                        "summary": "Module summary"
                    }},
                    "estimated_duration": "30 minutes",
                    "quiz": {{
                        "title": "Module Quiz",
                        "description": "Test your understanding",
                        "questions": [
                            {{
                                "id": "q1",
                                "text": "Question text",
                                "type": "multiple_choice",
                                "options": [
                                    {{"id": "a", "text": "Option A"}},
                                    {{"id": "b", "text": "Option B"}},
                                    {{"id": "c", "text": "Option C"}},
                                    {{"id": "d", "text": "Option D"}}
                                ],
                                "correct_answer": "a",
                                "explanation": "Explanation of the correct answer"
                            }}
                        ],
                        "passing_score": 80
                    }}
                }}
            ]
            """
            
            # Get the modules
            modules_response = self.groq_api.complete(modules_prompt, {
                'temperature': 0.5,
                'maxTokens': 4000,
                'system': 'You are an expert course content creator. Produce detailed educational modules in JSON format.'
            })
            
            # Parse the modules
            try:
                modules = json.loads(modules_response.text)
            except json.JSONDecodeError:
                # Fallback if the response isn't valid JSON
                modules = self._generate_modules(course_info, profile)
            
            # Assemble the course content
            course_content = {
                "id": course_id,
                "title": course_info.get("title", "Untitled Course"),
                "description": course_info.get("description", ""),
                "overview": course_overview,
                "modules": modules,
                "employee_id": profile.get("employee_id"),
                "learning_objectives": course_info.get("learning_objectives", []),
                "metadata": {
                    "course_id": course_id,
                    "created_at": datetime.now().isoformat(),
                    "updated_at": datetime.now().isoformat(),
                    "generated_for": profile.get("employee_id"),
                    "generated_with": "Groq API"
                }
            }
            
            # Save the course content
            save_path = save_course_content(course_id, course_content)
            print(f"Course content saved to: {save_path}")
            
            return course_content
            
        except Exception as e:
            print(f"Error generating course content with Groq API: {str(e)}")
            # Fallback to mock content generation
            return self._generate_mock_course_content(course_id, course_info, profile)
    
    def _generate_mock_course_content(self, course_id, course_info, profile):
        """Generate mock course content as a fallback"""
        # Generate course overview
        course_overview = self._generate_course_overview(course_info, profile)
        
        # Generate modules
        modules = self._generate_modules(course_info, profile)
        
        # Assemble course content
        course_content = {
            "id": course_id,
            "title": course_info.get("title", "Untitled Course"),
            "description": course_info.get("description", ""),
            "overview": course_overview,
            "modules": modules,
            "employee_id": profile.get("employee_id"),
            "learning_objectives": course_info.get("learning_objectives", []),
            "metadata": {
                "course_id": course_id,
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat(),
                "generated_for": profile.get("employee_id"),
                "generated_with": "mock generator"
            }
        }
        
        # Save the course content
        save_path = save_course_content(course_id, course_content)
        print(f"Mock course content saved to: {save_path}")
        
        return course_content
    
    def _generate_course_overview(self, course_info, profile):
        """Generate a course overview based on course info and profile"""
        # In a real implementation, this would use the LLM
        return {
            "summary": f"This course covers {course_info.get('title')} with a focus on practical applications.",
            "key_concepts": [
                "Understanding core principles",
                "Practical application techniques",
                f"Advanced topics in {course_info.get('title')}"
            ],
            "prerequisites": [],
            "target_audience": [profile.get("role", "Professionals")],
            "difficulty_level": self._determine_difficulty(profile.get("experience", "mid-level")),
            "estimated_completion_time": course_info.get("estimated_duration", "10 hours")
        }
    
    def _determine_difficulty(self, experience_level):
        """Determine course difficulty based on experience level"""
        if experience_level in ["entry-level", "beginner"]:
            return "Beginner"
        elif experience_level in ["mid-level", "intermediate"]:
            return "Intermediate"
        else:
            return "Advanced"
    
    def _generate_modules(self, course_info, profile):
        """Generate course modules based on course info and profile"""
        # Define module count based on course duration
        duration_str = course_info.get("estimated_duration", "10 hours")
        try:
            duration_hours = int(duration_str.split()[0])
            module_count = max(3, min(8, duration_hours // 2))  # 3-8 modules based on duration
        except:
            module_count = 4  # Default
        
        modules = []
        
        # Create modules
        for i in range(module_count):
            module = self._create_module(i+1, course_info, profile)
            modules.append(module)
        
        return modules
    
    def _create_module(self, module_num, course_info, profile):
        """Create a single module with content"""
        # Module titles based on position in course
        if module_num == 1:
            title = f"Introduction to {course_info.get('title', 'the Course')}"
        elif module_num == 2:
            title = f"Core Concepts of {course_info.get('title', 'the Subject')}"
        else:
            title = f"Advanced Topic {module_num-2}: {self._generate_topic_name(course_info, module_num)}"
        
        # Create module structure with sections
        module = {
            "id": f"module_{str(uuid.uuid4())[:8]}",
            "title": title,
            "sequence_order": module_num,
            "content": {
                "introduction": f"In this module, you'll learn about {title.lower()}. " +
                               f"This is important for {profile.get('role', 'professionals')} because it helps you " +
                               f"develop essential skills in {course_info.get('title', 'this subject')}.",
                "sections": self._generate_sections(3 + module_num % 2, title),  # 3-4 sections per module
                "summary": f"In this module, you've learned the key concepts of {title.lower()}. " +
                          f"You should now be able to apply these principles in your work."
            },
            "estimated_duration": f"{30 + module_num * 15} minutes",
            "quiz": self._generate_quiz(title, 5)  # 5 questions
        }
        
        return module
    
    def _generate_topic_name(self, course_info, module_num):
        """Generate a topic name for a module"""
        # In a real implementation, this would use the LLM
        topics = [
            "Practical Applications",
            "Best Practices",
            "Case Studies",
            "Integration Techniques",
            "Future Trends",
            "Performance Optimization",
            "Security Considerations"
        ]
        return topics[module_num % len(topics)]
    
    def _generate_sections(self, section_count, module_title):
        """Generate sections for a module"""
        sections = []
        
        for i in range(section_count):
            section = {
                "title": f"Section {i+1}: {self._generate_section_title(module_title, i+1)}",
                "content": [
                    {
                        "type": "text",
                        "value": f"This section explains the key concept {i+1} of {module_title.lower()}. " +
                                f"You'll learn how to apply this in practical scenarios."
                    },
                    {
                        "type": "code_example" if i % 3 == 0 else "image",
                        "value": f"Example {i+1} demonstrating the concept" if i % 3 == 0 else "Diagram illustrating the concept"
                    },
                    {
                        "type": "text",
                        "value": "The above example shows how the concept can be applied in a real-world setting."
                    }
                ]
            }
            sections.append(section)
        
        return sections
    
    def _generate_section_title(self, module_title, section_num):
        """Generate a title for a section"""
        # In a real implementation, this would use the LLM
        if section_num == 1:
            return f"Understanding {module_title.split(':')[-1].strip()}"
        elif section_num == 2:
            return "Key Principles and Techniques"
        elif section_num == 3:
            return "Practical Applications"
        else:
            return "Advanced Concepts and Future Directions"
    
    def _generate_quiz(self, module_title, question_count):
        """Generate a quiz for a module"""
        questions = []
        
        for i in range(question_count):
            question = {
                "id": f"q_{str(uuid.uuid4())[:8]}",
                "text": f"Question about {module_title.lower()} concept {i+1}",
                "type": "multiple_choice" if i % 3 != 0 else "true_false",
                "options": [
                    {"id": "a", "text": "First potential answer"},
                    {"id": "b", "text": "Second potential answer"},
                    {"id": "c", "text": "Third potential answer"},
                    {"id": "d", "text": "Fourth potential answer"}
                ] if i % 3 != 0 else [
                    {"id": "true", "text": "True"},
                    {"id": "false", "text": "False"}
                ],
                "correct_answer": "a" if i % 3 != 0 else "true",
                "explanation": f"Explanation of why the answer is correct, referring to {module_title.lower()}"
            }
            questions.append(question)
        
        return {
            "title": f"Quiz: {module_title}",
            "description": f"Test your understanding of {module_title.lower()}",
            "questions": questions,
            "passing_score": 80
        }
    
    def create_courses_for_learning_path(self, employee_id):
        """
        Create course content for all courses in a learning path
        
        Args:
            employee_id: The ID of the employee
            
        Returns:
            List of created courses with status
        """
        # Load the learning path
        learning_path = load_learning_path(employee_id)
        if not learning_path:
            raise ValueError(f"No learning path found for employee {employee_id}")
        
        # Extract courses from learning path
        courses = learning_path.get("courses", [])
        if not courses:
            raise ValueError(f"No courses found in learning path for employee {employee_id}")
        
        created_courses = []
        
        # Create content for each course
        for course in courses:
            course_id = course.get("id", f"course_{str(uuid.uuid4())[:8]}")
            try:
                self.create_course_content(employee_id, course_id, course)
                created_courses.append({
                    "course_id": course_id,
                    "title": course.get("title", "Untitled Course"),
                    "success": True
                })
            except Exception as e:
                print(f"Error creating content for course {course_id}: {str(e)}")
                created_courses.append({
                    "course_id": course_id,
                    "title": course.get("title", "Untitled Course"),
                    "success": False,
                    "error": str(e)
                })
                
        return created_courses

# Simple test function
def test_content_creation():
    """Test the content creation agent"""
    # Test employee ID
    employee_id = "emp001"
    
    # Create agent
    agent = ContentCreationAgent()
    
    try:
        # Create courses for learning path
        print(f"Creating courses for employee {employee_id}...")
        created_courses = agent.create_courses_for_learning_path(employee_id)
        
        # Print results
        print(f"\nCreated {len(created_courses)} courses:")
        for course in created_courses:
            status = "✅ Success" if course.get("success", False) else "❌ Failed"
            print(f"- {course.get('title', 'Untitled')}: {status}")
        
        print("\nTest complete!")
    except Exception as e:
        print(f"Error during test: {e}")
        
if __name__ == "__main__":
    test_content_creation() 